def do_scp(pp_env: pest_pde.Env):\n    # Define constants\n    #pp_env = pest_pde.Env()\n    n_s = pp_env.n**2\n    n = 3*n_s  # state dimension\n    m = n_s  # control dimension\n    s0, u0 = pest_pde.init_state(pp_env)\n    s_goal = np.concatenate([np.ones((n_s,)), np.zeros((n_s,)), np.zeros((n_s,))])  # desired field state\n    dt = 0.1  # discrete time resolution\n    T = 10.0  # total simulation time\n    P = 1e3 * np.eye(n)  # terminal state cost matrix\n    Q = 1e1 * np.eye(n) # state cost matrix\n    R = 1e-1 * np.eye(m)  # control cost matrix\n    ρ = 0.5  # trust region parameter\n    u_max = 0.5  # control effort bound\n    eps = 5e-2  # convergence tolerance\n    max_iters = 100  # maximum number of SCP iterations\n    animate = False  # flag for animation\n\n    pest = pest_pde.PestSim(pp_env)\n    # Initialize the discrete-time dynamics\n    fd = jax.jit(discretize(pest.pests_wrapper_su_jax, dt))\n\n    # Solve the swing-up problem with SCP\n    t = np.arange(0.0, T + dt, dt)\n    N = t.size - 1\n    s, u, J = solve_swingup_scp(fd, s0, s_goal, N, P, Q, R, u_max, ρ, eps, max_iters)\n\n    serialize_scp_run(s, u, J, pp_env)\n\n    # Simulate open-loop control\n    #for k in range(N):\n    #    s[k + 1] = fd(s[k], u[k])\n
